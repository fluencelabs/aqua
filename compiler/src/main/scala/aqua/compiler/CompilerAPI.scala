package aqua.compiler

import aqua.backend.{AirString, Backend}
import aqua.linker.{AquaModule, Linker, Modules}
import aqua.model.AquaContext
import aqua.parser.lift.{LiftParser, Span}
import aqua.parser.{Ast, ParserError}
import aqua.raw.RawPart.Parts
import aqua.raw.{RawContext, RawPart}
import aqua.res.AquaRes
import aqua.semantics.{CompilerState, LspSemantics, RawSemantics, Semantics}
import aqua.semantics.header.{HeaderHandler, HeaderSem}
import aqua.semantics.lsp.LspContext
import cats.data.*
import cats.data.Validated.{validNec, Invalid, Valid, invalid}
import cats.parse.Parser0
import cats.syntax.applicative.*
import cats.syntax.flatMap.*
import cats.syntax.functor.*
import cats.syntax.monoid.*
import cats.syntax.traverse.*
import cats.syntax.semigroup.*
import cats.{~>, Comonad, Monad, Monoid, Order}
import scribe.Logging

import scala.collection.MapView

object CompilerAPI extends Logging {

  private def toAquaProcessed[I: Order, E, S[_]: Comonad](
    filesWithContext: Map[
      I,
      ValidatedNec[AquaError[I, E, S], NonEmptyMap[I, RawContext]]
    ]
  ): ValidatedNec[AquaError[I, E, S], Chain[AquaProcessed[I]]] = {
    logger.trace("linking finished")
    filesWithContext
      .foldLeft[
        (
          ValidatedNec[AquaError[I, E, S], Chain[AquaProcessed[I]]],
          AquaContext.Cache
        )
      ](
        validNec(Chain.nil) -> AquaContext.Cache()
      ) {
        case ((acc, cache), (_, Valid(result))) =>
          val (processed, cacheProcessed) =
            result.toNel.toList.foldLeft[
              (Chain[AquaProcessed[I]], AquaContext.Cache)
            ](
              Chain.nil -> cache
            ) { case ((acc, accCache), (i, rawContext)) =>
              logger.trace(s"Going to prepare exports for $i...")
              val (exp, expCache) = AquaContext.exportsFromRaw(rawContext, accCache)
              logger.trace(s"AquaProcessed prepared for $i")
              (acc :+ AquaProcessed(i, exp)) -> expCache
            }
          acc.combine(
            validNec(
              processed
            )
          ) -> cacheProcessed
        case ((acc, cache), (_, Invalid(errs))) =>
          acc.combine(Invalid(errs)) -> cache
      }
      ._1
  }

  private def getLspAquaCompiler[F[_]: Monad, E, I: Order, S[_]: Comonad](
    config: AquaCompilerConf
  ): AquaCompiler[F, E, I, S, LspContext[S]] = {
    implicit val rc: Monoid[LspContext[S]] = LspContext
      .implicits(
        LspContext
          .blank[S]
          .copy(raw =
            RawContext.blank.copy(parts =
              Chain.fromSeq(config.constantsList).map(const => RawContext.blank -> const)
            )
          )
      )
      .lspContextMonoid

    implicit val headerSemMonoid: Monoid[HeaderSem[S, LspContext[S]]] =
      new Monoid[HeaderSem[S, LspContext[S]]] {
        override def empty: HeaderSem[S, LspContext[S]] = HeaderSem(rc.empty, (c, _) => validNec(c))

        override def combine(
          a: HeaderSem[S, LspContext[S]],
          b: HeaderSem[S, LspContext[S]]
        ): HeaderSem[S, LspContext[S]] = {
          HeaderSem(
            a.initCtx |+| b.initCtx,
            (c, i) => a.finInitCtx(c, i).andThen(b.finInitCtx(_, i))
          )
        }
      }

    val semantics = new LspSemantics[S]()

    new AquaCompiler[F, E, I, S, LspContext[S]](new HeaderHandler[S, LspContext[S]](), semantics)
  }

  private def getAquaCompiler[F[_]: Monad, E, I: Order, S[_]: Comonad](
    config: AquaCompilerConf
  ): AquaCompiler[F, E, I, S, RawContext] = {
    implicit val rc: Monoid[RawContext] = RawContext
      .implicits(
        RawContext.blank
          .copy(parts = Chain.fromSeq(config.constantsList).map(const => RawContext.blank -> const))
      )
      .rawContextMonoid

    implicit val headerSemMonoid: Monoid[HeaderSem[S, RawContext]] =
      new Monoid[HeaderSem[S, RawContext]] {
        override def empty: HeaderSem[S, RawContext] = HeaderSem(rc.empty, (c, _) => validNec(c))

        override def combine(
          a: HeaderSem[S, RawContext],
          b: HeaderSem[S, RawContext]
        ): HeaderSem[S, RawContext] =
          HeaderSem(
            a.initCtx |+| b.initCtx,
            (c, i) => a.finInitCtx(c, i).andThen(b.finInitCtx(_, i))
          )
      }

    val semantics = new RawSemantics[S]()

    new AquaCompiler[F, E, I, S, RawContext](new HeaderHandler[S, RawContext](), semantics)
  }

  // Get result generated by backend
  def compile[F[_]: Monad, E, I: Order, S[_]: Comonad](
    sources: AquaSources[F, E, I],
    parser: I => String => ValidatedNec[ParserError[S], Ast[S]],
    airValidator: AirValidator[F],
    backend: Backend.Transform,
    config: AquaCompilerConf
  ): F[ValidatedNec[AquaError[I, E, S], Chain[AquaCompiled[I]]]] = {
    val compiler = getAquaCompiler[F, E, I, S](config)

    for {
      compiledV <- compiler
          .compileRaw(sources, parser)
          .map(_.andThen { filesWithContext =>
            toAquaProcessed(filesWithContext)
          })
      _ <- airValidator.init()
      result <- compiledV.map { compiled =>
          compiled.map { ap =>
            logger.trace("generating output...")
            val res = backend.transform(ap.context)
            val compiled = backend.generate(res)
            airValidator
              .validate(
                compiled.toList.flatMap(_.air)
              )
              .map(
                _.bimap(
                  errs => NonEmptyChain.one(AirValidationError(errs): AquaError[I, E, S]),
                  _ =>
                    AquaCompiled(ap.id, compiled, res.funcs.length.toInt, res.services.length.toInt)
                )
              )
          }.sequence.map(_.sequence)
        } match {
          case Valid(f) => f
          case Invalid(e) =>
            invalid[NonEmptyChain[AquaError[I, E, S]], Chain[AquaCompiled[I]]](e).pure[F]
        }
    } yield result
  }

  def compileTo[F[_]: Monad, E, I: Order, S[_]: Comonad, T](
    sources: AquaSources[F, E, I],
    parser: I => String => ValidatedNec[ParserError[S], Ast[S]],
    airValidator: AirValidator[F],
    backend: Backend.Transform,
    config: AquaCompilerConf,
    write: AquaCompiled[I] => F[Seq[Validated[E, T]]]
  ): F[ValidatedNec[AquaError[I, E, S], Chain[T]]] =
    compile[F, E, I, S](sources, parser, airValidator, backend, config).flatMap {
      case Valid(compiled) =>
        compiled.map { ac =>
          write(ac).map(
            _.map(
              _.bimap[NonEmptyChain[AquaError[I, E, S]], Chain[T]](
                e => NonEmptyChain.one(OutputError(ac, e)),
                Chain.one
              )
            )
          )
        }.toList
          .traverse(identity)
          .map(
            _.flatten
              .foldLeft[ValidatedNec[AquaError[I, E, S], Chain[T]]](validNec(Chain.nil))(
                _ combine _
              )
          )

      case Validated.Invalid(errs) =>
        Validated.invalid[NonEmptyChain[AquaError[I, E, S]], Chain[T]](errs).pure[F]
    }

  def compileToLsp[F[_]: Monad, E, I: Order, S[_]: Comonad](
    sources: AquaSources[F, E, I],
    parser: I => String => ValidatedNec[ParserError[S], Ast[S]],
    config: AquaCompilerConf
  ): F[Validated[NonEmptyChain[AquaError[I, E, S]], Map[I, Validated[NonEmptyChain[
    AquaError[I, E, S]
  ], Map[I, LspContext[S]]]]]] = {

    val compiler = getLspAquaCompiler[F, E, I, S](config)
    compiler
      .compileRaw(sources, parser)
      .map { v =>
        v.map { innerMap =>
          innerMap.view.mapValues { vCtx =>
            vCtx.map {
              _.toSortedMap.toMap
            }
          }.toMap
        }
      }
  }

  def compileToContext[F[_]: Monad, E, I: Order, S[_]: Comonad](
    sources: AquaSources[F, E, I],
    parser: I => String => ValidatedNec[ParserError[S], Ast[S]],
    config: AquaCompilerConf
  ): F[ValidatedNec[AquaError[I, E, S], Chain[AquaContext]]] = {

    val compiler = getAquaCompiler[F, E, I, S](config)
    compiler
      .compileRaw(sources, parser)
      .map(_.andThen { filesWithContext =>
        toAquaProcessed(filesWithContext)
      })
      .map(_.map { compiled =>
        compiled.map { ap =>
          logger.trace("generating output...")
          ap.context
        }
      })
  }
}
