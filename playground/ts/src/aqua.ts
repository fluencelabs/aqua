/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.1.13-SNAPSHOT
 *
 */
import { FluencePeer } from "@fluencelabs/fluence";
import {
  ResultCodes,
  RequestFlow,
  RequestFlowBuilder,
  CallParams,
} from "@fluencelabs/fluence/dist/internal/compilerSupport/v1";

// Services

const registerHelloWorldImpl = (peer: FluencePeer) => {
  return (
    options: { serviceId: string },
    service: {
      hello: (s: string, callParams: CallParams<"s">) => void;
    }
  ) => {
    peer.callServiceHandler.use((req, resp, next) => {
      if (req.serviceId !== options.serviceId) {
        next();
        return;
      }

      if (req.fnName === "hello") {
        const callParams = {
          ...req.particleContext,
          tetraplets: {
            s: req.tetraplets[0],
          },
        };
        resp.retCode = ResultCodes.success;
        service.hello(req.args[0], callParams);
        resp.result = {};
      }

      next();
    });
  };
};

export const registerHelloWorld = registerHelloWorldImpl(FluencePeer.default);

declare module "@fluencelabs/fluence" {
  interface FluencePeer {
    registerHelloWorld: (
      options: { serviceId: string },
      service: {
        hello: (s: string, callParams: CallParams<"s">) => void;
      }
    ) => void;
  }
}

FluencePeer.prototype.registerHelloWorld = function (o, s) {
  return registerHelloWorldImpl(this)(o, s);
};

const registerMoreMembersImpl = (peer: FluencePeer) => {
  return (
    options: { serviceId: string },
    service: {
      member1: (callParams: CallParams<null>) => void;
      member2: (s1: string, callParams: CallParams<"s1">) => void;
      member3: (
        s1: string,
        s2: string,
        callParams: CallParams<"s1" | "s2">
      ) => void;
      member4: (
        s1: string,
        s2: string,
        i: number,
        callParams: CallParams<"s1" | "s2" | "i">
      ) => number;
      member5: (
        s1: string,
        s2: string,
        i: number,
        callParams: CallParams<"s1" | "s2" | "i">
      ) => number;
    }
  ) => {
    peer.callServiceHandler.use((req, resp, next) => {
      if (req.serviceId !== options.serviceId) {
        next();
        return;
      }

      if (req.fnName === "member1") {
        const callParams = {
          ...req.particleContext,
          tetraplets: {},
        };
        resp.retCode = ResultCodes.success;
        service.member1(callParams);
        resp.result = {};
      }

      if (req.fnName === "member2") {
        const callParams = {
          ...req.particleContext,
          tetraplets: {
            s1: req.tetraplets[0],
          },
        };
        resp.retCode = ResultCodes.success;
        service.member2(req.args[0], callParams);
        resp.result = {};
      }

      if (req.fnName === "member3") {
        const callParams = {
          ...req.particleContext,
          tetraplets: {
            s1: req.tetraplets[0],
            s2: req.tetraplets[1],
          },
        };
        resp.retCode = ResultCodes.success;
        service.member3(req.args[0], req.args[1], callParams);
        resp.result = {};
      }

      if (req.fnName === "member4") {
        const callParams = {
          ...req.particleContext,
          tetraplets: {
            s1: req.tetraplets[0],
            s2: req.tetraplets[1],
            i: req.tetraplets[2],
          },
        };
        resp.retCode = ResultCodes.success;
        resp.result = service.member4(
          req.args[0],
          req.args[1],
          req.args[2],
          callParams
        );
      }

      if (req.fnName === "member5") {
        const callParams = {
          ...req.particleContext,
          tetraplets: {
            s1: req.tetraplets[0],
            s2: req.tetraplets[1],
            i: req.tetraplets[2],
          },
        };
        resp.retCode = ResultCodes.success;
        resp.result = service.member5(
          req.args[0],
          req.args[1],
          req.args[2],
          callParams
        );
      }

      next();
    });
  };
};

export const registerMoreMembers = registerMoreMembersImpl(FluencePeer.default);

declare module "@fluencelabs/fluence" {
  interface FluencePeer {
    registerMoreMembers: (
      options: { serviceId: string },
      service: {
        member1: (callParams: CallParams<null>) => void;
        member2: (s1: string, callParams: CallParams<"s1">) => void;
        member3: (
          s1: string,
          s2: string,
          callParams: CallParams<"s1" | "s2">
        ) => void;
        member4: (
          s1: string,
          s2: string,
          i: number,
          callParams: CallParams<"s1" | "s2" | "i">
        ) => number;
        member5: (
          s1: string,
          s2: string,
          i: number,
          callParams: CallParams<"s1" | "s2" | "i">
        ) => number;
      }
    ) => void;
  }
}

FluencePeer.prototype.registerMoreMembers = function (o, s) {
  return registerMoreMembersImpl(this)(o, s);
};

// Functions

const sayHelloImpl = (peer: FluencePeer) => {
  return async (config?: { ttl?: number }): Promise<void> => {
    let request: RequestFlow;
    const promise = new Promise<void>((resolve, reject) => {
      const r = new RequestFlowBuilder()
        .disableInjections()
        .withRawScript(
          `
    (xor
 (seq
  (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
  (call %init_peer_id% ("hello_world" "hello") ["hello, world"])
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
)

                `
        )
        .configHandler((h) => {
          h.on("getDataSrv", "-relay-", () => {
            return peer.connectionInfo.connectedRelays[0];
          });

          h.onEvent("callbackSrv", "response", (args) => {});

          h.onEvent("errorHandlingSrv", "error", (args) => {
            const [err] = args;
            reject(err);
          });
        })
        .handleScriptError(reject)
        .handleTimeout(() => {
          reject("Request timed out for sayHello");
        });
      if (config && config.ttl) {
        r.withTTL(config.ttl);
      }
      request = r.build();
    });
    await peer.initiateFlow(request!);
    return Promise.race([promise, Promise.resolve()]);
  };
};

export const sayHello = sayHelloImpl(FluencePeer.default);

declare module "@fluencelabs/fluence" {
  interface FluencePeer {
    sayHello: (config?: { ttl?: number }) => Promise<void>;
  }
}

FluencePeer.prototype.sayHello = function (...args) {
  return sayHelloImpl(this)(...args);
};

const callBackZeroArgsImpl = (peer: FluencePeer) => {
  return async (
    callback: (callParams: CallParams<null>) => void,
    config?: { ttl?: number }
  ): Promise<void> => {
    let request: RequestFlow;
    const promise = new Promise<void>((resolve, reject) => {
      const r = new RequestFlowBuilder()
        .disableInjections()
        .withRawScript(
          `
    (xor
 (seq
  (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
  (xor
   (call %init_peer_id% ("callbackSrv" "callback") [])
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
)

                `
        )
        .configHandler((h) => {
          h.on("getDataSrv", "-relay-", () => {
            return peer.connectionInfo.connectedRelays[0];
          });

          h.use((req, resp, next) => {
            if (req.serviceId === "callbackSrv" && req.fnaAme === "callback") {
              const callParams = {
                ...req.particleContext,
                tetraplets: {},
              };
              resp.retCode = ResultCodes.success;
              callback(callParams);
              resp.result = {};
            }
            next();
          });

          h.onEvent("callbackSrv", "response", (args) => {});

          h.onEvent("errorHandlingSrv", "error", (args) => {
            const [err] = args;
            reject(err);
          });
        })
        .handleScriptError(reject)
        .handleTimeout(() => {
          reject("Request timed out for callBackZeroArgs");
        });
      if (config && config.ttl) {
        r.withTTL(config.ttl);
      }
      request = r.build();
    });
    await peer.initiateFlow(request!);
    return Promise.race([promise, Promise.resolve()]);
  };
};

export const callBackZeroArgs = callBackZeroArgsImpl(FluencePeer.default);

declare module "@fluencelabs/fluence" {
  interface FluencePeer {
    callBackZeroArgs: (
      callback: (callParams: CallParams<null>) => void,
      config?: { ttl?: number }
    ) => Promise<void>;
  }
}

FluencePeer.prototype.callBackZeroArgs = function (...args) {
  return callBackZeroArgsImpl(this)(...args);
};

const f1Impl = (peer: FluencePeer) => {
  return async (
    callback: (
      arg0: string,
      arg1: number,
      callParams: CallParams<"arg0" | "arg1">
    ) => void,
    config?: { ttl?: number }
  ): Promise<void> => {
    let request: RequestFlow;
    const promise = new Promise<void>((resolve, reject) => {
      const r = new RequestFlowBuilder()
        .disableInjections()
        .withRawScript(
          `
    (xor
 (seq
  (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
  (xor
   (call %init_peer_id% ("callbackSrv" "callback") ["hello, world" 42])
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
)

                `
        )
        .configHandler((h) => {
          h.on("getDataSrv", "-relay-", () => {
            return peer.connectionInfo.connectedRelays[0];
          });

          h.use((req, resp, next) => {
            if (req.serviceId === "callbackSrv" && req.fnaAme === "callback") {
              const callParams = {
                ...req.particleContext,
                tetraplets: {
                  arg0: req.tetraplets[0],
                  arg1: req.tetraplets[1],
                },
              };
              resp.retCode = ResultCodes.success;
              callback(req.args[0], req.args[1], callParams);
              resp.result = {};
            }
            next();
          });

          h.onEvent("callbackSrv", "response", (args) => {});

          h.onEvent("errorHandlingSrv", "error", (args) => {
            const [err] = args;
            reject(err);
          });
        })
        .handleScriptError(reject)
        .handleTimeout(() => {
          reject("Request timed out for f1");
        });
      if (config && config.ttl) {
        r.withTTL(config.ttl);
      }
      request = r.build();
    });
    await peer.initiateFlow(request!);
    return Promise.race([promise, Promise.resolve()]);
  };
};

export const f1 = f1Impl(FluencePeer.default);

declare module "@fluencelabs/fluence" {
  interface FluencePeer {
    f1: (
      callback: (
        arg0: string,
        arg1: number,
        callParams: CallParams<"arg0" | "arg1">
      ) => void,
      config?: { ttl?: number }
    ) => Promise<void>;
  }
}

FluencePeer.prototype.f1 = function (...args) {
  return f1Impl(this)(...args);
};

const f3Impl = (peer: FluencePeer) => {
  return async (
    num: number,
    callback: (
      arg0: string,
      arg1: number,
      callParams: CallParams<"arg0" | "arg1">
    ) => void,
    config?: { ttl?: number }
  ): Promise<string> => {
    let request: RequestFlow;
    const promise = new Promise<string>((resolve, reject) => {
      const r = new RequestFlowBuilder()
        .disableInjections()
        .withRawScript(
          `
    (xor
 (seq
  (seq
   (seq
    (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
    (call %init_peer_id% ("getDataSrv" "num") [] num)
   )
   (xor
    (call %init_peer_id% ("callbackSrv" "callback") ["hello, world" 42])
    (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
   )
  )
  (xor
   (call %init_peer_id% ("callbackSrv" "response") ["hello world"])
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
)

                `
        )
        .configHandler((h) => {
          h.on("getDataSrv", "-relay-", () => {
            return peer.connectionInfo.connectedRelays[0];
          });
          h.on("getDataSrv", "num", () => {
            return num;
          });

          h.use((req, resp, next) => {
            if (req.serviceId === "callbackSrv" && req.fnaAme === "callback") {
              const callParams = {
                ...req.particleContext,
                tetraplets: {
                  arg0: req.tetraplets[0],
                  arg1: req.tetraplets[1],
                },
              };
              resp.retCode = ResultCodes.success;
              callback(req.args[0], req.args[1], callParams);
              resp.result = {};
            }
            next();
          });

          h.onEvent("callbackSrv", "response", (args) => {
            const [res] = args;
            resolve(res);
          });

          h.onEvent("errorHandlingSrv", "error", (args) => {
            const [err] = args;
            reject(err);
          });
        })
        .handleScriptError(reject)
        .handleTimeout(() => {
          reject("Request timed out for f3");
        });
      if (config && config.ttl) {
        r.withTTL(config.ttl);
      }
      request = r.build();
    });
    await peer.initiateFlow(request!);
    return promise;
  };
};

export const f3 = f3Impl(FluencePeer.default);

declare module "@fluencelabs/fluence" {
  interface FluencePeer {
    f3: (
      num: number,
      callback: (
        arg0: string,
        arg1: number,
        callParams: CallParams<"arg0" | "arg1">
      ) => void,
      config?: { ttl?: number }
    ) => Promise<string>;
  }
}

FluencePeer.prototype.f3 = function (...args) {
  return f3Impl(this)(...args);
};

const f2Impl = (peer: FluencePeer) => {
  return async (
    num: number,
    callback: (
      arg0: string,
      arg1: number,
      callParams: CallParams<"arg0" | "arg1">
    ) => void,
    config?: { ttl?: number }
  ): Promise<void> => {
    let request: RequestFlow;
    const promise = new Promise<void>((resolve, reject) => {
      const r = new RequestFlowBuilder()
        .disableInjections()
        .withRawScript(
          `
    (xor
 (seq
  (seq
   (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
   (call %init_peer_id% ("getDataSrv" "num") [] num)
  )
  (xor
   (call %init_peer_id% ("callbackSrv" "callback") ["hello, world" 42])
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
)

                `
        )
        .configHandler((h) => {
          h.on("getDataSrv", "-relay-", () => {
            return peer.connectionInfo.connectedRelays[0];
          });
          h.on("getDataSrv", "num", () => {
            return num;
          });

          h.use((req, resp, next) => {
            if (req.serviceId === "callbackSrv" && req.fnaAme === "callback") {
              const callParams = {
                ...req.particleContext,
                tetraplets: {
                  arg0: req.tetraplets[0],
                  arg1: req.tetraplets[1],
                },
              };
              resp.retCode = ResultCodes.success;
              callback(req.args[0], req.args[1], callParams);
              resp.result = {};
            }
            next();
          });

          h.onEvent("callbackSrv", "response", (args) => {});

          h.onEvent("errorHandlingSrv", "error", (args) => {
            const [err] = args;
            reject(err);
          });
        })
        .handleScriptError(reject)
        .handleTimeout(() => {
          reject("Request timed out for f2");
        });
      if (config && config.ttl) {
        r.withTTL(config.ttl);
      }
      request = r.build();
    });
    await peer.initiateFlow(request!);
    return Promise.race([promise, Promise.resolve()]);
  };
};

export const f2 = f2Impl(FluencePeer.default);

declare module "@fluencelabs/fluence" {
  interface FluencePeer {
    f2: (
      num: number,
      callback: (
        arg0: string,
        arg1: number,
        callParams: CallParams<"arg0" | "arg1">
      ) => void,
      config?: { ttl?: number }
    ) => Promise<void>;
  }
}

FluencePeer.prototype.f2 = function (...args) {
  return f2Impl(this)(...args);
};
